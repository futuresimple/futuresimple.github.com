---
kind: "article"
created_at: 2012-03-04 17:00:00
title: "CSRF Attack"
author: "Bart Kiszala"
identifier: "csrf-attack"
---

Most of you are aware of CSRF attack. I use JS on a daily basis but I actually never thought that the code I develop could be CSRF-prone.

You saw that coming -  I was wrong and I want to share that harsh lesson.

Let's assume you're developing a web app called omg-app.com (obviously because it's so god it will make everyone say OMG!). The app is getting bigger, lots of people use it, new features are being added on a weekly basis. At some point you conclude it would be nice to inform users about some recently added features.

How do you do that? The most common solution would be to display a banner for logged in users with newly released stuff.

Banner can be saying sth like:

    Hello bart@futuresimple.com! Great news - new file upload has just been released!

Fair enough. After quick brainstorming you decided that on every page where the banner is displayed you will load js script which adds the banner itself to the page. The code would look like this:

	#!html
    <script type="text/javascript" src="/banner.js"></script>

The only missing part now is the implementation of omg-app.com/banner action
which responds with javascript code. That should not be too much work. Perfect.

Sorry for the ugly code but if serves the purpose. In Rails it could look sth like:

	#!ruby
	before_filter :verify_user! #verifies if user is logged in

    def banner
      respond_to do |format|
        if current_user.saw_new_upload?
           format.js { render :js => " $('body').append("<div class='banner'/>");$('.banner').html('Hello  #{current_user.email}! Great news - new file upload has just been released!');" }
        else
          format.js { render :js => " " }
        end
      end
    end

Now if a user is logged in and she hasn't seen new upload yet - the following script will be loaded to the page:
(I assume jQuery is available )

	#!javascript
    $('body').append("<div class='banner'/>");
    $('.banner').html('Hello  bart@futuresimple.com!  Great news - new file upload has just been released!');

Great! Problem solved, time to play some office ping-pong… Not so fast dude.

As it happens omg-app.com is super popular and many people are logged in at all times. Authentication information for omg-app is
being kept in browsers' cookie. What is the problem?

Lets assume that my good pal Mike is logged in. At the same time he clicked on a link which leads to the site with funny cats
(what a lovely site it is …) in other tab of his browser.  Not only is the kitten site unbearably cute.  It's also malicious site and it
loads exactly the same script as omg-app.com:

	#!html
    <script type="text/javascript" src="/banner.js"></script>

Since Mike is logged in to omg-app - the kitten site gets the same response - meaning

	"Hello  bart@futuresimple.com - new file upload was just released".

Boom - email stolen.

How can it be fixed then?

My first idea was to verify if a script was loaded from omg-app.com domain on the server-side:

	#!ruby
	def banner
	   unless request.referrer_url.match( /^http:\/\/omg-app.com/) return ""
	   ...
	end

That solution isn't really good for the following reasons:
-  in Rails specifically you can't always  get the request_url of the page where script was loaded
-  if user browses in private mode (e.x. incognito mode in Chrome) your app'll never get the
   referrer url.

How about checking on the JS-side if the script is being loaded on omg-app.com and only then load the banner script asynchronously?

Seems like a great idea ... Now the code responsible for loading banner would look sth like:

	#!html
	<script type="text/javascript">
	$(function(){
	 var regex = /\.omg-app\.com$/

	  if (!regex.test(window.location.host)) {
	    return
	  }
	  // Load banner script asynchronously.
	});
	</script>

Bad news - this solution is even worse that the previous one:

- firstly, one can still load the banner script directly (without js domain verification)
- secondly, even if the malicious site would include the whole code above, RegExp.prototype.test method can be easily overwitten (welcome to JS world...) and returns always true.

	#!javascript
	RegExp.prototype.test = function() { return true }

Ok - so now I can pull out the big guns and include banner information in iframe on each page.
This starts to be really complicated and I'm not a big fun of iframes.

The solution I decided to go for is to load the banner after getting its content via an AJAX request.

My Rails action looks sth like:

	#!ruby
	before_filter :verify_user!

	def banner
	  respond_to do |format|
	    if current_user.saw_new_upload?
	       format.json { render :json => {:message => 'Hello  #{current_user.email} - new file upload was just released'  } }
	    else
	      format.json { render :json => {} }
	    end
	  end
	end

JS script on various pages:

	#!javascript
	(function() {
	  var methods = {
	    display_html: function(message) {
	      $('"<div class=\'banner\'/>");$('.banner').append(message)
	    }
	  }
	  $.get('/banner.json', function(data) {
	    display_html(data.message)
	  })
	}());


Why this solution is safe? (is it?!)
Because of [same origin policy](http://en.wikipedia.org/wiki/Same_origin_policy). In nutshell - only scripts (e.x. ajax requests) originating from the same site (app-omg.com) can access banner action in your web app.

That means that browser blocks any ajax requests originated on kitty site to access your application hence
CSRF attack described earlier is not a problem any more.

So far so good. There surely pitfalls (e.x. subdomains) of this approach  but that's the best one I came up with so far.
If you have any suggestions, share them!
